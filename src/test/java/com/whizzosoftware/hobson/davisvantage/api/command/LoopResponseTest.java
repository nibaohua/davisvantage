package com.whizzosoftware.hobson.davisvantage.api.command;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import java.text.ParseException;

import org.junit.Test;

public class LoopResponseTest {
    @Test
    public void testGoodLoopPacket() throws Exception {
        byte[] data = new byte[] {
                0x4c,0x4f,0x4f,0x00,0x00,(byte)0xbf,0x02,(byte)0xe7,0x74,(byte)0xef,0x02,0x1f,0x04,0x03,
                0x01,0x01,0x1d,0x01,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,
                (byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,
                (byte)0xff,0x20,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,
                (byte)0xff,0x00,0x00,(byte)0xff,(byte)0xff,0x7f,0x00,0x00,(byte)0xff,(byte)0xff,0x00,0x00,
                0x71,0x00,(byte)0x96,0x08,0x00,0x00,0x00,0x00,0x00,0x00,(byte)0xff,(byte)0xff,(byte)0xff,
                (byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x03,0x06,0x2d,0x71,0x02,(byte)0x8f,0x07,
                0x0a,0x0d,0x6e,(byte)0xa2
        };
        
        data = new byte[] {
	 			0x4c, 0x4f, 0x4F, (byte) 0xEC, 0x00, (byte) 0x9A, 0x05,
	 			0x7E, 0x75, 0x46, 0x02, 0x49, 0x18, 0x02, 0x04, 0x02, (byte) 0xF6, 0x00,
	 			(byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF,
	 			(byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, 
	 			(byte) 0xFF, (byte)0xFF, (byte) 0xFF, (byte)0xFF, (byte)0xFF,(byte) 0xFF, 0x62, (byte) 0xFF, (byte)0xFF,
	 			(byte)0xFF, (byte)0xFF, (byte)0xFF,(byte) 0xFF, (byte)0xFF, 0x00, 0x00, (byte)0xFF, 0x28,
	 			0x00, 0x44, 0x00, 0x12, (byte) 0xCB, 0x43, 0x00, (byte)0xFF, 0x01, (byte) 0xBE, 0x12, 0x02, 0x00, 0x31, 0x00,
	 			(byte) 0xEC, 0x0C, (byte)0xFF, (byte)0xFF,(byte) 0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	 			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2B, 0x03,
	 			0x06, 0x2C, (byte) 0x8B, 0x02, (byte) 0xA7, 0x06, 0x0A, 0x0D, (byte) 0xEA, 0x26 
	 	};
		String hex = new String("4C 4F 4F EC 00 9A 05 7E 75 46 02 49 "
				+ "18 02 04 02 F6 00 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF 62 "
				+ "FF FF FF FF FF FF FF 00 00 FF 28 00 44 00 12 CB 43 00 FF 01 BE 12 "
				+ "02 00 31 00 EC 0C FF FF FF FF FF FF FF 00 00 00 00 00 00 00 00 00 "
				+ "00 00 00 00 00 00 00 00 00 2B 03 06 2C 8B 02 A7 06 0A 0D EA 26 ");

//        String hexString = HexConvert.BinaryToHexString( hex.getBytes() );//含有空格，如：2A 30 30 30 30 37 56 45 52 53 49 4F 4E 5C 6E 31 24 
		String hexString= new String(hex.getBytes("utf-8"));
        hexString =  hexString.replace( " ","" );//去除空格
        
        data = HexConvert.hexStringToBytes(hexString);
        LoopResponse lr = new LoopResponse(data);
        System.out.println("response:"+lr.toString());
        assertEquals(0, (int)lr.getBarTrend());
        assertEquals(29927, (int)lr.getBarometer());
        assertEquals(751, (int)lr.getInsideTemp());
        assertEquals(31, (int)lr.getInsideHumidity());
        assertEquals(772, (int)lr.getOutsideTemp());
        assertEquals(32, (int)lr.getOutsideHumidity());
    }
    
    public static byte[] hexStringToBytes(String hexString) {
	    if (hexString == null || hexString.equals("")) {
	        return null;
	    }
	    // toUpperCase将字符串中的所有字符转换为大写
	    hexString = hexString.toUpperCase();
	    int length = hexString.length() / 2;
	    // toCharArray将此字符串转换为一个新的字符数组。
	    char[] hexChars = hexString.toCharArray();
	    byte[] d = new byte[length];
	    for (int i = 0; i < length; i++) {
	        int pos = i * 2;
	        d[i] = (byte) (charToByte(hexChars[pos]) << 4 | charToByte(hexChars[pos + 1]));
	    }
	    return d;
	}
    
  //返回匹配字符
  	private static byte charToByte(char c) {
  	    return (byte) "0123456789ABCDEF".indexOf(c);
  	}
  	
  	

   // @Test
    public void testShortLoopPacket() throws Exception {
        byte[] data = new byte[] {
                0x4c,0x4f,0x4f,0x00,0x00,(byte)0xbf,0x02,(byte)0xe7,0x74,(byte)0xef,0x02,0x1f,0x04,0x03,
                0x01,0x01,0x1d,0x01,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,
                (byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,
                (byte)0xff,0x20,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,
                (byte)0xff,0x00,0x00,(byte)0xff,(byte)0xff,0x7f,0x00,0x00,(byte)0xff,(byte)0xff,0x00,0x00,
                0x71,0x00,(byte)0x96,0x08,0x00,0x00,0x00,0x00,0x00,0x00,(byte)0xff,(byte)0xff,(byte)0xff,
                (byte)0xff,(byte)0xff,(byte)0xff,(byte)0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
        };
        try {
            new LoopResponse(data);
            fail("Should have thrown exception");
        } catch (ParseException ignored) {}
    }
}
